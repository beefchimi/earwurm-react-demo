/* eslint-disable */

// @ts-nocheck

// noinspection JSUnusedGlobalSymbols

// This file was automatically generated by TanStack Router.
// You should NOT make any changes in this file as it will be overwritten.
// Additionally, you should also exclude this file from your linter and/or formatter to prevent it from being checked or modified.

import { createFileRoute } from '@tanstack/react-router'

// Import Routes

import { Route as rootRoute } from './routes/__root'

// Create Virtual Routes

const VisibilityLazyImport = createFileRoute('/visibility')()
const SequenceLazyImport = createFileRoute('/sequence')()
const RestrictedLazyImport = createFileRoute('/restricted')()
const QueuedLazyImport = createFileRoute('/queued')()
const OverlapLazyImport = createFileRoute('/overlap')()
const CascadeLazyImport = createFileRoute('/cascade')()
const AutoSuspendLazyImport = createFileRoute('/auto-suspend')()
const AsynchronousLazyImport = createFileRoute('/asynchronous')()
const IndexLazyImport = createFileRoute('/')()

// Create/Update Routes

const VisibilityLazyRoute = VisibilityLazyImport.update({
  id: '/visibility',
  path: '/visibility',
  getParentRoute: () => rootRoute,
} as any).lazy(() => import('./routes/visibility.lazy').then((d) => d.Route))

const SequenceLazyRoute = SequenceLazyImport.update({
  id: '/sequence',
  path: '/sequence',
  getParentRoute: () => rootRoute,
} as any).lazy(() => import('./routes/sequence.lazy').then((d) => d.Route))

const RestrictedLazyRoute = RestrictedLazyImport.update({
  id: '/restricted',
  path: '/restricted',
  getParentRoute: () => rootRoute,
} as any).lazy(() => import('./routes/restricted.lazy').then((d) => d.Route))

const QueuedLazyRoute = QueuedLazyImport.update({
  id: '/queued',
  path: '/queued',
  getParentRoute: () => rootRoute,
} as any).lazy(() => import('./routes/queued.lazy').then((d) => d.Route))

const OverlapLazyRoute = OverlapLazyImport.update({
  id: '/overlap',
  path: '/overlap',
  getParentRoute: () => rootRoute,
} as any).lazy(() => import('./routes/overlap.lazy').then((d) => d.Route))

const CascadeLazyRoute = CascadeLazyImport.update({
  id: '/cascade',
  path: '/cascade',
  getParentRoute: () => rootRoute,
} as any).lazy(() => import('./routes/cascade.lazy').then((d) => d.Route))

const AutoSuspendLazyRoute = AutoSuspendLazyImport.update({
  id: '/auto-suspend',
  path: '/auto-suspend',
  getParentRoute: () => rootRoute,
} as any).lazy(() => import('./routes/auto-suspend.lazy').then((d) => d.Route))

const AsynchronousLazyRoute = AsynchronousLazyImport.update({
  id: '/asynchronous',
  path: '/asynchronous',
  getParentRoute: () => rootRoute,
} as any).lazy(() => import('./routes/asynchronous.lazy').then((d) => d.Route))

const IndexLazyRoute = IndexLazyImport.update({
  id: '/',
  path: '/',
  getParentRoute: () => rootRoute,
} as any).lazy(() => import('./routes/index.lazy').then((d) => d.Route))

// Populate the FileRoutesByPath interface

declare module '@tanstack/react-router' {
  interface FileRoutesByPath {
    '/': {
      id: '/'
      path: '/'
      fullPath: '/'
      preLoaderRoute: typeof IndexLazyImport
      parentRoute: typeof rootRoute
    }
    '/asynchronous': {
      id: '/asynchronous'
      path: '/asynchronous'
      fullPath: '/asynchronous'
      preLoaderRoute: typeof AsynchronousLazyImport
      parentRoute: typeof rootRoute
    }
    '/auto-suspend': {
      id: '/auto-suspend'
      path: '/auto-suspend'
      fullPath: '/auto-suspend'
      preLoaderRoute: typeof AutoSuspendLazyImport
      parentRoute: typeof rootRoute
    }
    '/cascade': {
      id: '/cascade'
      path: '/cascade'
      fullPath: '/cascade'
      preLoaderRoute: typeof CascadeLazyImport
      parentRoute: typeof rootRoute
    }
    '/overlap': {
      id: '/overlap'
      path: '/overlap'
      fullPath: '/overlap'
      preLoaderRoute: typeof OverlapLazyImport
      parentRoute: typeof rootRoute
    }
    '/queued': {
      id: '/queued'
      path: '/queued'
      fullPath: '/queued'
      preLoaderRoute: typeof QueuedLazyImport
      parentRoute: typeof rootRoute
    }
    '/restricted': {
      id: '/restricted'
      path: '/restricted'
      fullPath: '/restricted'
      preLoaderRoute: typeof RestrictedLazyImport
      parentRoute: typeof rootRoute
    }
    '/sequence': {
      id: '/sequence'
      path: '/sequence'
      fullPath: '/sequence'
      preLoaderRoute: typeof SequenceLazyImport
      parentRoute: typeof rootRoute
    }
    '/visibility': {
      id: '/visibility'
      path: '/visibility'
      fullPath: '/visibility'
      preLoaderRoute: typeof VisibilityLazyImport
      parentRoute: typeof rootRoute
    }
  }
}

// Create and export the route tree

export interface FileRoutesByFullPath {
  '/': typeof IndexLazyRoute
  '/asynchronous': typeof AsynchronousLazyRoute
  '/auto-suspend': typeof AutoSuspendLazyRoute
  '/cascade': typeof CascadeLazyRoute
  '/overlap': typeof OverlapLazyRoute
  '/queued': typeof QueuedLazyRoute
  '/restricted': typeof RestrictedLazyRoute
  '/sequence': typeof SequenceLazyRoute
  '/visibility': typeof VisibilityLazyRoute
}

export interface FileRoutesByTo {
  '/': typeof IndexLazyRoute
  '/asynchronous': typeof AsynchronousLazyRoute
  '/auto-suspend': typeof AutoSuspendLazyRoute
  '/cascade': typeof CascadeLazyRoute
  '/overlap': typeof OverlapLazyRoute
  '/queued': typeof QueuedLazyRoute
  '/restricted': typeof RestrictedLazyRoute
  '/sequence': typeof SequenceLazyRoute
  '/visibility': typeof VisibilityLazyRoute
}

export interface FileRoutesById {
  __root__: typeof rootRoute
  '/': typeof IndexLazyRoute
  '/asynchronous': typeof AsynchronousLazyRoute
  '/auto-suspend': typeof AutoSuspendLazyRoute
  '/cascade': typeof CascadeLazyRoute
  '/overlap': typeof OverlapLazyRoute
  '/queued': typeof QueuedLazyRoute
  '/restricted': typeof RestrictedLazyRoute
  '/sequence': typeof SequenceLazyRoute
  '/visibility': typeof VisibilityLazyRoute
}

export interface FileRouteTypes {
  fileRoutesByFullPath: FileRoutesByFullPath
  fullPaths:
    | '/'
    | '/asynchronous'
    | '/auto-suspend'
    | '/cascade'
    | '/overlap'
    | '/queued'
    | '/restricted'
    | '/sequence'
    | '/visibility'
  fileRoutesByTo: FileRoutesByTo
  to:
    | '/'
    | '/asynchronous'
    | '/auto-suspend'
    | '/cascade'
    | '/overlap'
    | '/queued'
    | '/restricted'
    | '/sequence'
    | '/visibility'
  id:
    | '__root__'
    | '/'
    | '/asynchronous'
    | '/auto-suspend'
    | '/cascade'
    | '/overlap'
    | '/queued'
    | '/restricted'
    | '/sequence'
    | '/visibility'
  fileRoutesById: FileRoutesById
}

export interface RootRouteChildren {
  IndexLazyRoute: typeof IndexLazyRoute
  AsynchronousLazyRoute: typeof AsynchronousLazyRoute
  AutoSuspendLazyRoute: typeof AutoSuspendLazyRoute
  CascadeLazyRoute: typeof CascadeLazyRoute
  OverlapLazyRoute: typeof OverlapLazyRoute
  QueuedLazyRoute: typeof QueuedLazyRoute
  RestrictedLazyRoute: typeof RestrictedLazyRoute
  SequenceLazyRoute: typeof SequenceLazyRoute
  VisibilityLazyRoute: typeof VisibilityLazyRoute
}

const rootRouteChildren: RootRouteChildren = {
  IndexLazyRoute: IndexLazyRoute,
  AsynchronousLazyRoute: AsynchronousLazyRoute,
  AutoSuspendLazyRoute: AutoSuspendLazyRoute,
  CascadeLazyRoute: CascadeLazyRoute,
  OverlapLazyRoute: OverlapLazyRoute,
  QueuedLazyRoute: QueuedLazyRoute,
  RestrictedLazyRoute: RestrictedLazyRoute,
  SequenceLazyRoute: SequenceLazyRoute,
  VisibilityLazyRoute: VisibilityLazyRoute,
}

export const routeTree = rootRoute
  ._addFileChildren(rootRouteChildren)
  ._addFileTypes<FileRouteTypes>()

/* ROUTE_MANIFEST_START
{
  "routes": {
    "__root__": {
      "filePath": "__root.tsx",
      "children": [
        "/",
        "/asynchronous",
        "/auto-suspend",
        "/cascade",
        "/overlap",
        "/queued",
        "/restricted",
        "/sequence",
        "/visibility"
      ]
    },
    "/": {
      "filePath": "index.lazy.tsx"
    },
    "/asynchronous": {
      "filePath": "asynchronous.lazy.tsx"
    },
    "/auto-suspend": {
      "filePath": "auto-suspend.lazy.tsx"
    },
    "/cascade": {
      "filePath": "cascade.lazy.tsx"
    },
    "/overlap": {
      "filePath": "overlap.lazy.tsx"
    },
    "/queued": {
      "filePath": "queued.lazy.tsx"
    },
    "/restricted": {
      "filePath": "restricted.lazy.tsx"
    },
    "/sequence": {
      "filePath": "sequence.lazy.tsx"
    },
    "/visibility": {
      "filePath": "visibility.lazy.tsx"
    }
  }
}
ROUTE_MANIFEST_END */
